#!/usr/bin/env julia

#========================================================================================================# 
#    ReadingHDF5.jl
#    --------------
#
#    @AUTHOR   : Julio Soria
#    email     : julio.soria@monash.edu
#    date      : 14-10-2024
#    updated   : 25-10-2024
#    
#    This code contains functions to:
#        1. read HDF5 files
#        2. interpolate functions
#        3. integrate functions using trapezoidal rule
#        4. compute Reynard Deck decomposition
#       
#========================================================================================================#

# include libraries
using HDF5
using Interpolations, BSplineKit
using QuadGK

# include the necessary functions
# 1. Function to compute the x-derivative
include("PadeDifferentiation.jl")
include("FourierDifferentiation.jl")
include("FD-Differentiation.jl")

# ============== Helper Functions for Integration ==============
function interp1(x, y, xi) 
    """
    interpolation used for trapezoidal rule
    """
    idx = searchsortedfirst(x, xi)
    if idx == 1
        return y[1]
    elseif idx > length(x)
        return y[end]
    else
        return y[idx-1] + (xi - x[idx-1]) * (y[idx] - y[idx-1]) / (x[idx] - x[idx-1])
    end
end

function trapz(x, y)
    """
    trapezoidal rule for integration
    """
    return quadgk(z -> interp1(x, y, z), x[1], x[end])[1]
end

function cumtrapz(x, y)
    """
    cummulative rule for integration
    """
    return [quadgk(z -> interp1(x, y, z), x[1], x[k])[1] for k in 1:length(x)]
end

# =========== End Helper Functions =============


# Function to read an HDF5 file provided by Antonio Matas - different structure to file that is generated by statistics fie of TBL simulation
function read_hdf5_file(filename)
    data = Dict{String, Any}()
    
    println("Reading file: ", filename)
    try
        HDF5.h5open(filename, "r") do h5_file
            for name in keys(h5_file)
                obj = h5_file[name]
                data[name] = read(obj)
            end
            ib_DoI  = data["ib_DoI"]
            ie_DoI  = data["ie_DoI"]
            Re      = data["Re"]
            ν       = 1.0 / Re
            x       = data["x"]
            y       = data["y"]
            delta   = data["delta"]
            delta99 = data["delta99"]
            theta   = data["theta"]
            U       = data["ua"]
            V       = data["va"]
            P       = data["pm"]
            uP      = data["uP"] # uP - pressure velocity
            ut      = data["ut"] # u_\tau 
            pp      = data["pp"]
            uu      = data["uu"]
            uv      = data["uv"]
            vv      = data["vv"]
            ww      = data["ww"]
            println("File read successfully")
        end
    catch err
        println("Error reading file: ", err)
    end    
    return ib_DoI, ie_DoI, Re, ν, x, y, delta, delta99, theta, U, V, P, uP, ut, pp, uu, uv, vv, ww
end


function readTBLStatisticsFile(filename)
    """
    Function to read the statistics file from the TBL simulation - ORIGINAL
    """
    input_file_stats = h5open(filename, "r")
    Re     = read(input_file_stats["Re"])[1]
    rho    = 1.0
    nu     = 1.0 / Re
    mu     = nu * rho
    cfl    = read(input_file_stats["cfl"])[1]
    nstats = Int(read(input_file_stats["nstats"])[1])
    ax     = read(input_file_stats["ax"])[1]
    ay     = read(input_file_stats["ay"])[1]
    az     = read(input_file_stats["az"])[1]
    lx     = ax * π
    ly     = read(input_file_stats["y"])[end] - read(input_file_stats["y"])[1]
    lz     = az * π
    nx     = Int(read(input_file_stats["nx"])[1])
    dx     = ax * π / nx
    nyAll  = Int(read(input_file_stats["ny"])[1])
    nz2    = Int(read(input_file_stats["nz2"])[1])
    nz1    = (nz2 + 1) * 2
    nz     = nz1 * 3 / 2 + 2
    time   = read(input_file_stats["tiempo"])[1]
    println("\nReading geometry ...")
    yAll   = read(input_file_stats["y"])
    y      = yAll[2:end-1]
    ny     = length(y)
    dy     = zeros(Float64, ny)
    for i in 1:ny
        dy[i] = yAll[i+2] - yAll[i+1]
    end
    x      = [i * dx for i in 1:nx]
    println("\nReading average fields ...")
    pA     = read(input_file_stats["pm"])
    uA     = read(input_file_stats["ua"])
    vA     = read(input_file_stats["va"])
    wA     = read(input_file_stats["wa"])
    println("\nReading and processing variance and Reynolds stress fields ...\n")
    pp     = read(input_file_stats["pp"]) .- pA .* pA
    uu     = read(input_file_stats["us"]) .- uA .* uA
    vv     = read(input_file_stats["vs"]) .- vA .* vA
    ww     = read(input_file_stats["ws"]) .- wA .* wA
    uv     = read(input_file_stats["uv"]) .- uA .* vA
    uw     = read(input_file_stats["uw"]) .- uA .* wA
    vw     = read(input_file_stats["vw"]) .- vA .* wA
    close(input_file_stats)
    return Re, mu, lx, ly, nx, ny, x, y, yAll, uA, vA, wA, pA, uu, vv, ww, uv, uw, vw, pp
end


function InterpolateFunction(xold, xnew, fun, flag = "linear")
"""
    Interpolate the function fun(xold) to xnew
    Note: extrapolation is linear extrapolation beyond the boundaries
"""
    if flag == "linear"
        itp = LinearInterpolation(xold, fun, extrapolation_bc=Line())
    elseif flag == "cubic" # cubic spline interpolation which can deal with unequal spacings
        itp = BSplineKit.interpolate(xold, fun, BSplineOrder(3))
    end
    fun_new = itp.(xnew)
    return fun_new
end


function omega_z(y, dx, U, V)
"""
Compute the spanwise vorticity omega_z = dV/dx - dU/dy

    Arguments:
        y:  y-coordinates
        dx: x-spacing
        U: mean U(x,y) - stored as U[1:ny,1:nx]
        V: mean V(x,y) - stored as V[1:ny,1:nx]
"""
    dVdx    = compute_PadeFD(V, dx, dim=2)
    dUdy    = compute_PadeFD(U, y, dim=1)
    omega_z = dVdx - dUdy
    return omega_z
end


function ComputeViscousCharacteristics(y, U, nu)
"""
Compute viscous characteristics of a boundary layer.

    Arguments:
        y:  y-coordinates, can be unequally spaced!!!
        U:  mean U(x,y) - stored as U[1:ny,1:nx]
        nu: kinematic viscosity

    Returns:
        u_tau: Friction velocity, sqrt(nu*dUdy_w)
        lPlus: Non-dimensional length scale, nu/u_tau
"""
    dUdy  = compute_PadeFD(U, y, dim=1)
    u_tau = sqrt.(nu .* dUdy[:, 1])
    lPlus = nu ./ u_tau
    return u_tau, lPlus
end


function compute_Uₑ_δ₁_δ₂(y, Ω_z, debug = false)
    """
    Compute Velocity and length scales following: 
    Lighthill (1963) in Laminar Boundary Layers, Rosenhead (ed) and from Spalart and Watmuff (1993) JFM

    Arguments:
        y:  y-coordinates
        Ω_z: spanwise vorticity, stored as Ω_z[1:ny,1:nx]
        debug: debug flag
    Returns:
        Uₑ: mean velocity at the edge of the boundary layer
        δ₁: length scale 1
        δ₂: length scale 2
    """
    # extract nx and ny
    ny, nx = size(Ω_z)
    # assign memory
    Uₑ = zeros(nx) # assign memory forUₑ(x)
    δ₁ = zeros(nx) # assign memory for δ₁(x)
    δ₂ = zeros(nx) # assign memory for δ₂(x)
    # compute the integrals
    for j in 1:nx
        if debug
            println("Computing Uₑ, δ₁, δ₂ at xⱼ = ", j)
        end
        U_ω   = cumtrapz(y, -Ω_z[:, j]) # note that integration starts from the wall y = 0
        Uₑ[j] = U_ω[end]
        itp   = LinearInterpolation(y, -(y .* Ω_z[:, j]), extrapolation_bc=Line())
        δ₁[j] = (1.0 / Uₑ[j]) * quadgk(itp, y[1], y[end])[1]
        itp   = LinearInterpolation(y, -(y .* U_ω .* Ω_z[:, j]), extrapolation_bc=Line())
        δ₂[j] = (2.0 / Uₑ[j]^2) * quadgk(itp, y[1], y[end])[1] - δ₁[j]
        if debug
            println("Uₑ = ", Uₑ[j], ", δ₁ = ", δ₁[j], ", δ₂ = ", δ₂[j])
        end
    end
    return Uₑ, δ₁, δ₂
end


function Compute_Cfₐ(y, U, ν , Uₑ)
    # extract nx and ny
    ny, nx = size(U)
    # assign memory ...
    Cfₐ   = zeros(ny, nx)
    I_Cfₐ = zeros(ny, nx)
    # compute C_f_a ...
    dUdy = compute_PadeFD(U, y, dim=1)
    for j in 1:nx
        I_Cfₐ[:, j] = dUdy[:, j].^2 .* ν .* (2.0 ./ Uₑ[j].^3)
        Cfₐ[j, :]   = cumtrapz(y, I_Cfₐ[:, j])
    end
    return I_Cfₐ, Cfₐ
end


function Compute_Cfᵦ(y, uv, U, Uₑ)
    # extract nx and ny
    ny, nx = size(U)
    # assign memory ...
    Cfᵦ  = zeros(ny, nx)
    I_Cᵦ = zeros(ny, nx)
    # compute C_f_b ...
    dUdy = compute_PadeFD(U, y, dim=1)
    for j in 1:nx
        I_Cfᵦ[:, j] = -uv[:, j] .* dUdy[:, j] .* (2.0 ./ Uₑ[j].^3)
        Cfᵦ[:, j]   = cumtrapz(y, I_Cfᵦ[:, j])
    end
    return I_Cfᵦ, Cfᵦ
end


function Compute_Cfᵪ(y, uv, U, ν, Uₑ)
    # extract nx and ny
    ny, nx = size(U)
    # assign memory ...
    Cfᵪ   = zeros(ny, nx)
    I_Cfᵪ = zeros(ny, nx)
    # compute C_f_c ...
    dUdy  = compute_PadeFD(U, y, dim=1)
    τ     = ν .* dUdy - uv
    dτdy  = compute_PadeFD(τ, y, dim=1)
    for j in 1:nx
        I_Cfᵪ[:, j] = (U[:, j] .- Uₑ[j]) .* dτdy[:, j] .* (2.0 ./ Uₑ[j].^3)
        Cfᵪ[:, J]   = cumtrapz(y, I_Cfᵪ[:, j])
    end
    return I_Cfᵪ, Cfᵪ
end


function Compute_Cfₐ_Cfᵦ_Cfᵪ(y, U, ν, Uₑ, uv)
    # more efficient method to compute Cfₐ, Cfᵦ, Cfᵪ by removing duplicate computations
    # extract nx and ny
    ny, nx = size(U)
    # assign memory ...
    Cfₐ   = zeros(ny, nx)
    I_Cfₐ = zeros(ny, nx)
    Cfᵦ   = zeros(ny, nx)
    I_Cfᵦ = zeros(ny, nx)
    Cfᵪ   = zeros(ny, nx)
    I_Cfᵪ = zeros(ny, nx)
    # compute mean velocity gradient ...
    dUdy  = compute_PadeFD(U, y, dim=1)
    # compute gradient of total shear ...
    τ     = ν .* dUdy - uv
    dτdy  = compute_PadeFD(τ, y, dim=1)
    # compute Cfₐ, Cfᵦ, Cfᵪ ...
    for j in 1:nx
        I_Cfₐ[:, j] = dUdy[:, j].^2 .* ν .* (2.0 ./ Uₑ[j].^3)
        Cfₐ[:, j]   = cumtrapz(y, I_Cfₐ[:, j])
        I_Cfᵦ[:, j] = -uv[:, j] .* dUdy[:, j] .* (2.0 ./ Uₑ[j].^3)
        Cfᵦ[:, j]   = cumtrapz(y, I_Cfᵦ[:, j])
        I_Cfᵪ[:, j] = (U[:, j] .- Uₑ[j]) .* dτdy[:, j] .* (2.0 ./ Uₑ[j].^3)
        Cfᵪ[j, :]   = cumtrapz(y, I_Cfᵪ[:, j])
    end
    return I_Cfₐ, Cfₐ, I_Cfᵦ, Cfᵦ, I_Cfᵪ, Cfᵪ
end


function Compute_Cf(y, uv, U, ν, Uₑ)
    I_Cfₐ, Cfₐ, I_Cfᵦ, Cfᵦ, I_Cfᵪ, Cfᵪ = Compute_Cfₐ_Cfᵦ_Cfᵪ(y, U, ν, Uₑ, uv)
    Cf = Cfₐ + Cfᵦ + Cfᵪ
    return  I_Cfₐ, I_Cfᵦ,  I_Cfᵪ, Cfₐ, Cfᵦ, Cfᵪ, Cf
end


function main_1()
    # Example usage:
    dir_path  = "/Users/jsoria/CTRSS24/Resolvent/Resolvent_1D/Datasets/Sillero/"
    file_path = dir_path * "ZPG_Sillero_bl2.prof.h5"      # append the file name to the directory path

    ib_DoI, ie_DoI, Re, ν, x, y, delta, delta99, theta, U, V, P, uP, ut, pp, uu, uv, vv, ww = read_hdf5_file(file_path) = read_hdf5_file(file_path)
    
    ny, nx = size(U)
    ix     = ix = (ib_DoI + ie_DoI) ÷ 2
    ymin   = y[1]
    ymax   = y[end]

    # Calculate midpoints
    midpoints = y[1:end-1] .+ diff(y) ./ 2
    # Combine original y values with midpoints and sort
    y_new  = sort(vcat(y, midpoints))    
    ny_new = length(y_new)

    # Linear and cubic Interpolation of U[:,ix]
    U_lin = InterpolateFunction(y, y_new, U[:,ix], "linear")
    U_cub = InterpolateFunction(y, y_new, U[:,ix], "cubic")

    # plot the interpolated U[:,ix]
    fig1 = plot(y[2:end], U[2:end,ix], shape=:circ, label="Original U", xscale=:log10)
    plot!(fig1, y_new[2:end], U_lin[2:end], shape=:square, label="Linear Interpolated U", xscale=:log10)
    plot!(fig1, y_new[2:end], U_cub[2:end], shape=:diamond, label="Cubic Interpolated U", xscale=:log10)
    display(fig1)

    # plot V velocity
    fig2 = plot(y[2:end], V[2:end,ix], xscale=:log10, legend=false)  
    #for j = 2:nx
    #    plot!(fig2, y[2:end], V[2:end,j], xscale=:log10, legend=false)
    #end
    display(fig2)
end

function main_2()
    # Example usage:
    # dir_path  = "/Users/jsoria/CTRSS24/Datasets/Sillero/"
    # file_path = dir_path * "ZPG_Sillero_bl2.prof.h5"       # append the file name to the directory path
    # ib_DoI, ie_DoI, Re, ν, x, y, delta, delta99, theta, U, V, P, uP, ut, pp, uu, uv, vv, ww = read_hdf5_file(file_path)
    """
    DoI of ZPG:             ixDoImin=6789; ixDoImax=8183 
    DoI of beta1:           ixDoImin=3360; ixDoImax=3941
    DoI of beta_infinity:   ixDoImin=3800; ixDoImax=4800
    """
    
    dir_path  = "/Users/jsoria/CTRSS24/Datasets/LTRAC_data/DataFromVas/ZPG/"
    file_path = dir_path * "Beta0_tbl.sum.st.h5"
    println("Reading file: ", file_path)
    Re, ν, lx, ly, nx, ny, x, y, yAll, U, V, W, P, uu, vv, ww, uv, uw, vw, pp = readTBLStatisticsFile(file_path)
    ib_DoI, ie_DoI = 6789, 8183

    ny, nx = size(U)
    ix     = (ib_DoI + ie_DoI) ÷ 2
    ymin   = y[1]
    ymax   = y[end]
    dx     = x[2] - x[1]
    ib     = ib_DoI
    ie     = ie_DoI
    nx_DoI = ie - ib + 1

    dUdy = compute_PadeFD(U[:,ib:ie], y, dim=1)
    dVdy = compute_PadeFD(V[:,ib:ie], y, dim=1)
    fig6 = plot(y[2:end], dUdy[2:end,1], shape=:square, label="dU/dy", xlabel="y", ylabel="dUdy",xscale=:log10, legend=false)
    for j = 2:100:nx_DoI
        plot!(fig6, y[2:end], dUdy[2:end,j], shape=:square, label="dU/dy", xlabel="y", ylabel="dUdy", xscale=:log10, legend=false)
    end
    display(fig6)
    fig7 = plot(y[2:end], dVdy[2:end,1], shape=:circ, label="dV/dy", xlabel="y", ylabel="dVdy", xscale=:log10, legend=false)
    for j = 2:100:nx_DoI
        plot!(fig7, y[2:end], dVdy[2:end,j], shape=:circ, label="dV/dy", xlabel="y", ylabel="dVdy", xscale=:log10, legend=false)
    end
    display(fig7)

    # Calculate Ω_z = dV/dx - dU/dy
    println("Computing Ω_z")
    Ω_z = omega_z(y, dx, U[:,ib:ie], V[:,ib:ie]) # only in DoI

    fig1 = plot(y[2:end], Ω_z[2:end,1], shape=:square, label="omega_z", xlabel="y", ylabel="Ω_z", xscale=:log10, legend=false)
    for j = 2:100:nx_DoI
        plot!(fig1, y[2:end], Ω_z[2:end,j], shape=:square, label="omega_z", xlabel="y", ylabel="Ω_z", xscale=:log10, legend=false)
    end
    display(fig1)

    # Compute Uₑ, δ₁, δ₂ in DoI
    println("Computing Uₑ, δ₁, δ₂")
    Uₑ, δ₁, δ₂ = compute_Uₑ_δ₁_δ₂(y, Ω_z) # only in DoI

    fig2 = plot(x[ib:ie], Uₑ, shape=:square, label="Uₑ(x)", xlabel="x", ylabel="Uₑ", legend=false)
    display(fig2)

    fig3 = plot(x[ib:ie], δ₁, shape=:square, label="Uₑ(x)", xlabel="x", ylabel="δ₁", legend=false)
    display(fig3)

    fig4 = plot(x[ib:ie], δ₂, shape=:square, label="Uₑ(x)", xlabel="x", ylabel="δ₂", legend=false)
    display(fig4)

    dUedx = compute_x_derivative(dx, Uₑ) # only in DoI
    dδ₁dx = compute_x_derivative(dx, δ₁) # only in DoI
    dδ₂dx = compute_x_derivative(dx, δ₂) # only in DoI
    println(" Mean of dUₑ/dx = ", mean(dUedx))
    println(" Mean of dδ₁/dx = ", mean(dδ₁dx))
    println(" Mean of dδ₂/dx = ", mean(dδ₂dx))

    fig5 = plot(x[ib:ie], dUedx, shape=:square, xlabel="x", ylabel="dUedx", label="dU/dx")
    plot!(fig5, x[ib:ie], dδ₁dx, shape=:circ, xlabel="x", ylabel="dδ₁dx", label="dδ₁/dx")
    plot!(fig5, x[ib:ie], dδ₂dx, shape=:diamond, xlabel="x", ylabel="dδ₂dx", label="dδ₂/dx")
    display(fig5)
end

# run the main function if this 
#if abspath(PROGRAM_FILE) == @__FILE__
main_2()
#end