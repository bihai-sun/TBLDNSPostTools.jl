#!/usr/bin/env julia

# include libraries
using HDF5
using Interpolations, BSplineKit
using QuadGK
using DelimitedFiles

# include the necessary functions
# 1. Function to compute the x-derivative
include("m_differentiation.jl")

# ============== Helper Functions for Integration ==============
function interp1(x, y, xi) 
    """
    interpolation used for trapezoidal rule
    """
    idx = searchsortedfirst(x, xi)
    if idx == 1
        return y[1]
    elseif idx > length(x)
        return y[end]
    else
        return y[idx-1] + (xi - x[idx-1]) * (y[idx] - y[idx-1]) / (x[idx] - x[idx-1])
    end
end

function trapz(x, y)
    """
    trapezoidal rule for integration
    """
    return quadgk(z -> interp1(x, y, z), x[1], x[end])[1]
end

function cumtrapz(x, y)
    """
    cummulative rule for integration
    """
    return [quadgk(z -> interp1(x, y, z), x[1], x[k])[1] for k in 1:length(x)]
end

# =========== End Helper Functions =============


# Function to read an HDF5 file provided by Antonio Matas - different structure to file that is generated by statistics fie of TBL simulation
function read_hdf5_file(filename)
    data = Dict{String, Any}()
    
    println("Reading file: ", filename)
    try
        HDF5.h5open(filename, "r") do h5_file
            for name in keys(h5_file)
                obj = h5_file[name]
                data[name] = read(obj)
            end
            ib_DoI  = data["ib_DoI"]
            ie_DoI  = data["ie_DoI"]
            Re      = data["Re"]
            ν       = 1.0 / Re
            x       = data["x"]
            y       = data["y"]
            delta   = data["delta"]
            delta99 = data["delta99"]
            theta   = data["theta"]
            U       = data["ua"]
            V       = data["va"]
            P       = data["pm"]
            uP      = data["uP"] # uP - pressure velocity
            ut      = data["ut"] # u_\tau 
            pp      = data["pp"]
            uu      = data["uu"]
            uv      = data["uv"]
            vv      = data["vv"]
            ww      = data["ww"]
            println("File read successfully")
        end
    catch err
        println("Error reading file: ", err)
    end    
    return ib_DoI, ie_DoI, Re, ν, x, y, delta, delta99, theta, U, V, P, uP, ut, pp, uu, uv, vv, ww
end


function readTBLStatisticsFile(filename)
    """
    Function to read the statistics file from the TBL simulation - ORIGINAL
    """
    input_file_stats = h5open(filename, "r")
    Re     = read(input_file_stats["Re"])[1]
    rho    = 1.0
    nu     = 1.0 / Re
    mu     = nu * rho
    cfl    = read(input_file_stats["cfl"])[1]
    nstats = Int(read(input_file_stats["nstats"])[1])
    ax     = read(input_file_stats["ax"])[1]
    ay     = read(input_file_stats["ay"])[1]
    az     = read(input_file_stats["az"])[1]
    lx     = ax * π
    ly     = read(input_file_stats["y"])[end] - read(input_file_stats["y"])[1]
    lz     = az * π
    nx     = Int(read(input_file_stats["nx"])[1])
    dx     = ax * π / nx
    nyAll  = Int(read(input_file_stats["ny"])[1])
    nz2    = Int(read(input_file_stats["nz2"])[1])
    nz1    = (nz2 + 1) * 2
    nz     = nz1 * 3 / 2 + 2
    time   = read(input_file_stats["tiempo"])[1]
    println("\nReading geometry ...")
    yAll   = read(input_file_stats["y"])
    y      = yAll[2:end-1]
    ny     = length(y)
    dy     = zeros(Float64, ny)
    for i in 1:ny
        dy[i] = yAll[i+2] - yAll[i+1]
    end
    x      = [i * dx for i in 1:nx]
    println("\nReading average fields ...")
    pA     = read(input_file_stats["pm"])
    uA     = read(input_file_stats["ua"])
    vA     = read(input_file_stats["va"])
    wA     = read(input_file_stats["wa"])
    println("\nReading and processing variance and Reynolds stress fields ...\n")
    pp     = read(input_file_stats["pp"]) .- pA .* pA
    uu     = read(input_file_stats["us"]) .- uA .* uA
    vv     = read(input_file_stats["vs"]) .- vA .* vA
    ww     = read(input_file_stats["ws"]) .- wA .* wA
    uv     = read(input_file_stats["uv"]) .- uA .* vA
    uw     = read(input_file_stats["uw"]) .- uA .* wA
    vw     = read(input_file_stats["vw"]) .- vA .* wA
    close(input_file_stats)
    return Re, mu, lx, ly, nx, ny, x, y, yAll, uA, vA, wA, pA, uu, vv, ww, uv, uw, vw, pp
end


function InterpolateFunction(xold, xnew, fun, flag = "linear")
"""
Interpolate the function fun(xold) to xnew
    Note: extrapolation is a linear extrapolation beyond the boundaries
"""
    if flag == "linear"
        itp = LinearInterpolation(xold, fun, extrapolation_bc=Line())
    elseif flag == "cubic" # cubic spline interpolation which can deal with unequal spacings
        itp = BSplineKit.interpolate(xold, fun, BSplineOrder(3))
    end
    fun_new = itp.(xnew)
    return fun_new
end


function omega_z(y, dx, U, V)
    """
    Compute the spanwise vorticity omega_z = dV/dx - dU/dy

    Args:
        y: y-coordinates
        dx: x-spacing
        U: mean U(x,y) - stored as U[1:ny,1:nx]
        V: mean V(x,y) - stored as V[1:ny,1:nx]
    """
    dVdx = compute_x_derivative(dx, V)
    dUdy = compute_y_derivative(y, U)
    omega_z = dVdx - dUdy
    return omega_z
end


function ComputeViscousCharacteristics(y, U, nu)
    """
    Compute viscous characteristics of a boundary layer.

    Args:
        y:  y-coordinates, can be unequally spaced!!!
        U:  mean U(x,y) - stored as U[1:ny,1:nx]
        nu: kinematic viscosity

    Returns:
        u_tau: Friction velocity, sqrt(nu*dUdy_w)
        lPlus: Non-dimensional length scale, nu/u_tau
    """
    # Assuming compute_y_derivative is a function similar to the Python diff.ComputeYDerivative
    dUdy  = compute_y_derivative(y, U)
    u_tau = sqrt.(nu .* dUdy[1, :])
    lPlus = nu ./ u_tau
    return u_tau, lPlus
end


function compute_Uₑ_δ₁_δ₂(y, Ω_z, debug = false)
    """
    Compute Velocity and length scales following Lighthill (1963) in Laminar Boundary Layers, Rosenhead (ed) 
    and from Spalart and Watmuff (1993) JFM

    Choose the wall-normal location where Ω_z = 0.002 Ω_z[0, j] as the wall-normal location where Uₑ is computed
    Note: δ₁ and δ₂ are compute by integrating to the wall-normal location where Ω_z = 0.002 Ω_z[0, j]
    """
    # extract nx and ny
    ny, nx = size(Ω_z)
    # assign memory
    Uₑ = zeros(nx) # assign memory forUₑ(x)
    δ₁ = zeros(nx) # assign memory for δ₁(x)
    δ₂ = zeros(nx) # assign memory for δ₂(x)
    # Initialize an array to store the y locations for each j
    y_locations = zeros(Int, size(Ω_z, 2))

    # compute the integrals
    for j in 1:nx
        if debug
            println("Computing Uₑ, δ₁, δ₂ at xⱼ = ", j)
        end

        # find the wall-normal location where Ω_z = 0.002 Ω_z[0, j]
        # Find the target value for this column
        target_value = 0.002 * Ω_z[1, j]
        # Calculate the absolute difference between Ω_z[:, j] and the target value
        differences = abs.(Ω_z[:, j] .- target_value)
        # Find the index of the minimum difference
        y_location = findmin(differences)[2]
        # Store the y location for this column
        y_locations[j] = y_location
        U_ω   = cumtrapz(y[1:y_locations[j]], -Ω_z[1:y_locations[j], j]) # note that integration starts from the wall y = 0
        Uₑ[j] = U_ω[y_locations[j]]
        itp   = LinearInterpolation(y[1:y_locations[j]], -(y[1:y_locations[j]] .* Ω_z[1:y_locations[j], j]), extrapolation_bc=Line())
        δ₁[j] = (1.0 / Uₑ[j]) * quadgk(itp, y[1], y[y_locations[j]])[1]
        itp   = LinearInterpolation(y[1:y_locations[j]], -(y[1:y_locations[j]] .* U_ω[1:y_locations[j]] .* Ω_z[1:y_locations[j], j]), extrapolation_bc=Line())
        δ₂[j] = (2.0 / Uₑ[j]^2) * quadgk(itp, y[1], y[y_locations[j]])[1] - δ₁[j]
        if debug
            println("Uₑ = ", Uₑ[j], ", δ₁ = ", δ₁[j], ", δ₂ = ", δ₂[j])
        end
    end
    return Uₑ, δ₁, δ₂
end


function Compute_Cfₐ(y, U, ν , Uₑ)
    # extract nx and ny
    ny, nx = size(U)
    # assign memory ...
    Cfₐ   = zeros(ny, nx)
    I_Cfₐ = zeros(ny, nx)
    # compute C_f_a ...
    dUdy = compute_y_derivative(y, U) # Assuming computeYDerivative is defined elsewhere
    for j in 1:nx
        I_Cfₐ[:, j] = dUdy[:, j].^2 .* ν .* (2.0 ./ Uₑ[j].^3)
        Cfₐ[j, :]   = cumtrapz(y, I_Cfₐ[:, j])
    end
    return I_Cfₐ, Cfₐ
end


function Compute_Cfᵦ(y, uv, U, Uₑ)
    # extract nx and ny
    ny, nx = size(U)
    # assign memory ...
    Cfᵦ  = zeros(ny, nx)
    I_Cᵦ = zeros(ny, nx)
    # compute C_f_b ...
    dUdy = compute_y_derivative(y, U) # Assuming computeYDerivative is defined elsewhere
    for j in 1:nx
        I_Cfᵦ[:, j] = -uv[:, j] .* dUdy[:, j] .* (2.0 ./ Uₑ[j].^3)
        Cfᵦ[:, j]   = cumtrapz(y, I_Cfᵦ[:, j])
    end
    return I_Cfᵦ, Cfᵦ
end


function Compute_Cfᵪ(y, uv, U, ν, Uₑ)
    # extract nx and ny
    ny, nx = size(U)
    # assign memory ...
    Cfᵪ   = zeros(ny, nx)
    I_Cfᵪ = zeros(ny, nx)
    # compute C_f_c ...
    dUdy  = compute_y_derivative(y, U) # Assuming computeYDerivative is defined elsewhere
    τ     = ν .* dUdy - uv
    dτdy  = compute_y_derivative(y, τ)
    for j in 1:nx
        I_Cfᵪ[:, j] = (U[:, j] .- Uₑ[j]) .* dτdy[:, j] .* (2.0 ./ Uₑ[j].^3)
        Cfᵪ[:, J]   = cumtrapz(y, I_Cfᵪ[:, j])
    end
    return I_Cfᵪ, Cfᵪ
end


function Compute_Cfₐ_Cfᵦ_Cfᵪ(y, U, ν, Uₑ, uv)
    # more efficient method to compute Cfₐ, Cfᵦ, Cfᵪ by removing duplicate computations
    # extract nx and ny
    ny, nx = size(U)
    # assign memory ...
    Cfₐ   = zeros(ny, nx)
    I_Cfₐ = zeros(ny, nx)
    Cfᵦ   = zeros(ny, nx)
    I_Cfᵦ = zeros(ny, nx)
    Cfᵪ   = zeros(ny, nx)
    I_Cfᵪ = zeros(ny, nx)
    # compute mean velocity gradient ...
    dUdy  = compute_y_derivative(y, U) # Assuming computeYDerivative is defined elsewhere
    # compute gradient of total shear ...
    τ     = ν .* dUdy - uv
    dτdy  = compute_y_derivative(y, τ)
    # compute Cfₐ, Cfᵦ, Cfᵪ ...
    for j in 1:nx
        I_Cfₐ[:, j] = dUdy[:, j].^2 .* ν .* (2.0 ./ Uₑ[j].^3)
        Cfₐ[:, j]   = cumtrapz(y, I_Cfₐ[:, j])
        I_Cfᵦ[:, j] = -uv[:, j] .* dUdy[:, j] .* (2.0 ./ Uₑ[j].^3)
        Cfᵦ[:, j]   = cumtrapz(y, I_Cfᵦ[:, j])
        I_Cfᵪ[:, j] = (U[:, j] .- Uₑ[j]) .* dτdy[:, j] .* (2.0 ./ Uₑ[j].^3)
        Cfᵪ[j, :]   = cumtrapz(y, I_Cfᵪ[:, j])
    end
    return I_Cfₐ, Cfₐ, I_Cfᵦ, Cfᵦ, I_Cfᵪ, Cfᵪ
end


function Compute_Cf(y, uv, U, ν, Uₑ)
    I_Cfₐ, Cfₐ, I_Cfᵦ, Cfᵦ, I_Cfᵪ, Cfᵪ = Compute_Cfₐ_Cfᵦ_Cfᵪ(y, U, ν, Uₑ, uv)
    Cf = Cfₐ + Cfᵦ + Cfᵪ
    return  I_Cfₐ, I_Cfᵦ,  I_Cfᵪ, Cfₐ, Cfᵦ, Cfᵪ, Cf
end


function writeAverages2OutputFile(file_path, η, U_η_avg, V_η_avg, Ω_z_η_avg, uu_η_avg, vv_η_avg, ww_η_avg, uv_η_avg)
    """
    Write the streamwise-averaged [U/Uₑ(x) V/Uₑ(x) Ω_z/(Uₑ(x)/δ₁(x)) uu/(Uₑ(x)²) vv/(Uₑ(x)²) ww/(Uₑ(x)²) uv/(Uₑ(x)²)] to a text file
    """
    # Combine the arrays into a matrix. Each array becomes a column.
    data_matrix = hcat(η, U_η_avg, V_η_avg, Ω_z_η_avg, uu_η_avg, vv_η_avg, ww_η_avg, uv_η_avg)

    # Write the matrix to the file, using a tab as the delimiter
    writedlm(file_path, data_matrix, '\t')

    # If you want to include a header, you can write the header first and then append the data
    header = "#\tη\tU/Uₑ(x)\tV/Uₑ(x)\tΩ_z/(Uₑ(x)/δ₁(x))\tuu/(Uₑ(x)²)\tvv/(Uₑ(x)²)\tww/(Uₑ(x)²)\tuv/(Uₑ(x)²)\n"
    open(file_path, "w") do file
        write(file, header)
        writedlm(file, data_matrix, '\t')
    end
end


function test_1()
    # file path
    dir_path  = "/Users/jsoria/CTRSS24/Resolvent/Resolvent_1D/Datasets/Sillero/"
    file_path = dir_path * "ZPG_Sillero_bl2.prof.h5"      # append the file name to the directory path
    # read the data from the file:
    ib_DoI, ie_DoI, Re, ν, x, y, delta, delta99, theta, U, V, P, uP, ut, pp, uu, uv, vv, ww = read_hdf5_file(file_path)

    ny, nx = size(U)
    ix     = ix = (ib_DoI + ie_DoI) ÷ 2
    ymin   = y[1]
    ymax   = y[end]

    # Calculate midpoints
    midpoints = y[1:end-1] .+ diff(y) ./ 2
    # Combine original y values with midpoints and sort
    y_new = sort(vcat(y, midpoints))    
    ny_new = length(y_new)

    # Linear and cubic Interpolation of U[:,ix]
    U_lin = InterpolateFunction(y, y_new, U[:,ix], "linear")
    U_cub = InterpolateFunction(y, y_new, U[:,ix], "cubic")

    # plot the interpolated U[:,ix]
    fig1 = plot(y[2:end], U[2:end,ix], shape=:circ, label="Original U", xscale=:log10)
    plot!(fig1, y_new[2:end], U_lin[2:end], shape=:square, label="Linear Interpolated U", xscale=:log10)
    plot!(fig1, y_new[2:end], U_cub[2:end], shape=:diamond, label="Cubic Interpolated U", xscale=:log10)
    display(fig1)

    # plot V velocity
    fig2 = plot(y[2:end], V[2:end,ix], xscale=:log10, legend=false)  
    #for j = 2:nx
    #    plot!(fig2, y[2:end], V[2:end,j], xscale=:log10, legend=false)
    #end
    display(fig2)
end

function AverageStatisticsInEtaAcrossX(NPTS ,β = 0)
    # Specify the path to the file:
    # dir_path  = "/Users/jsoria/CTRSS24/Datasets/Sillero/"
    # file_path = dir_path * "ZPG_Sillero_bl2.prof.h5"       # append the file name to the directory path
    # read the data from the file:
    # ib_DoI, ie_DoI, Re, ν, x, y, delta, delta99, theta, U, V, P, uP, ut, pp, uu, uv, vv, ww = read_hdf5_file(file_path)

    """
    /Users/jsoria/CTRSS24/Datasets/LTRAC_data/DataFromVas/ZPG/Beta0_tbl.sum.st.h5
    DoI of ZPG:             ixDoImin=6789; ixDoImax=8183
    /Users/jsoria/CTRSS24/Datasets/LTRAC_data/DataFromVas/Beta=1/Beta1_tbl.sum.st.h5   
    DoI of beta1:           ixDoImin=3360; ixDoImax=3941
    /Users/jsoria/CTRSS24/Datasets/LTRAC_data/DataFromVas/Beta=39/Beta39_tbl.sum.st.h5
    DoI of beta_infinity:   ixDoImin=3800; ixDoImax=4800
    """
    if β == 0
        dir_path  = "/Users/jsoria/CTRSS24/Datasets/LTRAC_data/DataFromVas/ZPG/"
        file_path = dir_path * "Beta0_tbl.sum.st.h5"
        ofile_path = dir_path * "Beta0_UVWPPuuvvwwuv_eta_avg.txt"
        ib_DoI, ie_DoI = 6789, 8183
    elseif β == 1
        dir_path  = "/Users/jsoria/CTRSS24/Datasets/LTRAC_data/DataFromVas/Beta=1/"
        file_path = dir_path * "Beta1_tbl.sum.st.h5"
        ofile_path = dir_path * "Beta1_UVWPPuuvvwwuv_eta_avg.txt"
        ib_DoI, ie_DoI = 3360, 3941
    elseif β == 39
        dir_path  = "/Users/jsoria/CTRSS24/Datasets/LTRAC_data/DataFromVas/Beta=39/"
        file_path = dir_path * "Beta39_tbl.sum.st.h5"
        ofile_path = dir_path * "Beta39_UVWPPuuvvwwuv_eta_avg.txt"
        ib_DoI, ie_DoI = 3800, 4800
    end
    println("Reading file: ", file_path)
    Re, ν, lx, ly, nx, ny, x, y, yAll, U, V, W, P, uu, vv, ww, uv, uw, vw, pp = readTBLStatisticsFile(file_path)
    println("File read successfully")

    ny, nx = size(U)
    ix     = (ib_DoI + ie_DoI) ÷ 2
    ymin   = y[1]
    ymax   = y[end]
    dx     = x[2] - x[1]
    ib     = ib_DoI
    ie     = ie_DoI
    nx_DoI = ie - ib + 1

    #define η(x) = y/δ₁(x) - normalised wall distance array
    η = zeros(ny, nx_DoI) 

    # Calculate Ω_z = dV/dx - dU/dy
    println("Computing Ω_z")
    Ω_z = omega_z(y, dx, U[:,ib:ie], V[:,ib:ie]) # only in DoI

    # Compute Uₑ, δ₁, δ₂ in DoI
    println("Computing Uₑ, δ₁, δ₂")
    Uₑ, δ₁, δ₂ = compute_Uₑ_δ₁_δ₂(y, Ω_z) # only in DoI

    # Compute the viscous characteristics
    println("Computing viscous characteristics")
    u_tau, lPlus = ComputeViscousCharacteristics(y, U[:,ib:ie], ν)  

    # Compute η(x) = y/δ₁(x) - normalised wall distance array
    for j in 1:nx_DoI
        η[:, j] = y ./ δ₁[j]
    end

    # chose the maximum value of η to interpolate the statistics as the minimum value of maximum η, i.e. at the beginning of the DoI
    η_max = maximum(η[:,1])

    # Define number of points in equally spaced new η array with range 0 to η_max, space equally on a log scale
    n_η   = NPTS
    # Assuming η_max and n_η are defined
    log_start = -3 # This is for 10^-3
    log_end   = log10(η_max)
    # Generate logarithmically spaced points between 10^log_start and 10^log_end
    log_η_points = range(log_start, stop=log_end, length=n_η)
    η_new        = exp10.(log_η_points)        
    # interpolate normalized by Uₑ(x): U, V, uu, vv, ww, uv, Ω_z, to new equally-spaced η array
    println("Interpolating statistics to new η array")
    U_η   = zeros(n_η, nx_DoI)
    V_η   = zeros(n_η, nx_DoI)
    uu_η  = zeros(n_η, nx_DoI)
    vv_η  = zeros(n_η, nx_DoI)
    ww_η  = zeros(n_η, nx_DoI)
    uv_η  = zeros(n_η, nx_DoI)
    Ω_z_η = zeros(n_η, nx_DoI)
    for j in 1:nx_DoI
        U_η[:, j]   = InterpolateFunction(η[:, j], η_new, U[:, ib+j-1]/Uₑ[j],      "linear")
        V_η[:, j]   = InterpolateFunction(η[:, j], η_new, V[:, ib+j-1]/Uₑ[j],      "linear")
        uu_η[:, j]  = InterpolateFunction(η[:, j], η_new, uu[:, ib+j-1]/(Uₑ[j]^2), "linear")
        vv_η[:, j]  = InterpolateFunction(η[:, j], η_new, vv[:, ib+j-1]/(Uₑ[j]^2), "linear")
        ww_η[:, j]  = InterpolateFunction(η[:, j], η_new, ww[:, ib+j-1]/(Uₑ[j]^2), "linear")
        uv_η[:, j]  = InterpolateFunction(η[:, j], η_new, uv[:, ib+j-1]/(Uₑ[j]^2), "linear")
        Ω_z_η[:, j] = InterpolateFunction(η[:, j], η_new, Ω_z[:, j]/(Uₑ[j]/δ₁[j]), "linear")
    end

    # Average across x for each η value
    println("Averaging statistics across x for equal spaced η array")
    U_η_avg   = mean(U_η,   dims=2)
    V_η_avg   = mean(V_η,   dims=2)
    uu_η_avg  = mean(uu_η,  dims=2)
    vv_η_avg  = mean(vv_η,  dims=2)
    ww_η_avg  = mean(ww_η,  dims=2)
    uv_η_avg  = mean(uv_η,  dims=2)
    Ω_z_η_avg = mean(Ω_z_η, dims=2)

    # Write the averaged statistics to a file
    writeAverages2OutputFile(ofile_path, η_new, U_η_avg, V_η_avg, Ω_z_η_avg, uu_η_avg, vv_η_avg, ww_η_avg, uv_η_avg)
    
    fig1 = plot(η_new[2:end], U_η_avg[2:end], shape=:square, label="U_η", xlabel="η", ylabel="U/Uₑ", xscale=:log10, ylims=(0, 1.1), xlims=(0.001, 100), legend=false)
    for j = 2:100:nx_DoI
        plot!(fig1, η_new[2:end], U_η_avg[2:end], shape=:square, label="U_η", xlabel="η", ylabel="U/Uₑ", xscale=:log10, ylims=(0, 1.1), xlims=(0.001, 100), legend=false)
    end
    display(fig1)

    Vmax = maximum(V_η_avg)
    fig2 = plot(η_new[2:end], V_η_avg[2:end], shape=:square, label="V_η", xlabel="η", ylabel="V/Uₑ", xscale=:log10, ylims=(0, 1.05*Vmax), xlims=(0.001, 100), legend=false)
    for j = 2:100:nx_DoI
        plot!(fig2, η_new[2:end], V_η_avg[2:end], shape=:square, label="V_η", xlabel="η", ylabel="V/Uₑ", xscale=:log10, ylims=(0, 1.05*Vmax), xlims=(0.001, 100), legend=false)
    end
    display(fig2)

    Ω_z_max = maximum(abs.(Ω_z_η_avg))
    fig3 = plot(η_new[2:end], Ω_z_η_avg[2:end], shape=:square, label="Ω_z_η", xlabel="η", ylabel="Ω_z/(Uₑ/δ₁)", xscale=:log10, ylims=(-1.05*Ω_z_max, 0), xlims=(0.001, 100), legend=false)
    for j = 2:100:nx_DoI
        plot!(fig3, η_new[2:end], Ω_z_η_avg[2:end], shape=:square, label="Ω_z_η", xlabel="η", ylabel="Ω_z/(Uₑ/δ₁)", xscale=:log10, ylims=(-1.05*Ω_z_max, 0), xlims=(0.001, 100), legend=false)
    end
    display(fig3)  
    
    uu_η_max = maximum(abs.(uu_η_avg))
    fig4 = plot(η_new[2:end], uu_η_avg[2:end], shape=:square, label="uu_η", xlabel="η", ylabel="uu/(Uₑ^2)", xscale=:log10, ylims=(0, 1.05*uu_η_max), xlims=(0.001, 100), legend=false)
    for j = 2:100:nx_DoI
        plot!(fig4, η_new[2:end], uu_η_avg[2:end], shape=:square, label="uu_η", xlabel="η", ylabel="uu/(Uₑ^2)", xscale=:log10, ylims=(0, 1.05*uu_η_max), xlims=(0.001, 100), legend=false)
    end
    display(fig4)

    vv_η_max = maximum(abs.(vv_η_avg))
    fig5 = plot(η_new[2:end], vv_η_avg[2:end], shape=:square, label="vv_η", xlabel="η", ylabel="vv/(Uₑ^2)", xscale=:log10, ylims=(0, 1.05*vv_η_max), xlims=(0.001, 100), legend=false)
    for j = 2:100:nx_DoI
        plot!(fig5, η_new[2:end], vv_η_avg[2:end], shape=:square, label="vv_η", xlabel="η", ylabel="vv/(Uₑ^2)", xscale=:log10, ylims=(0, 1.05*vv_η_max), xlims=(0.001, 100), legend=false)
    end
    display(fig5)

    ww_η_max = maximum(abs.(ww_η_avg))
    fig6 = plot(η_new[2:end], ww_η_avg[2:end], shape=:square, label="ww_η", xlabel="η", ylabel="ww/(Uₑ^2)", xscale=:log10, ylims=(0, 1.05*ww_η_max), xlims=(0.001, 100), legend=false)
    for j = 2:100:nx_DoI
        plot!(fig6, η_new[2:end], ww_η_avg[2:end], shape=:square, label="ww_η", xlabel="η", ylabel="ww/(Uₑ^2)", xscale=:log10, ylims=(0, 1.05*ww_η_max), xlims=(0.001, 100), legend=false)
    end
    display(fig6)

    uv_η_max = maximum(abs.(uv_η_avg))
    fig7 = plot(η_new[2:end], uv_η_avg[2:end], shape=:square, label="uv_η", xlabel="η", ylabel="uv/(Uₑ^2)", xscale=:log10, ylims=(-1.05*uv_η_max, 1.05uv_η_max), xlims=(0.001, 100), legend=false)
    for j = 2:100:nx_DoI
        plot!(fig7, η_new[2:end], uv_η_avg[2:end], shape=:square, label="uv_η", xlabel="η", ylabel="uv/(Uₑ^2)", xscale=:log10, ylims=(-1.05*uv_η_max, 1.05*uv_η_max), xlims=(0.001, 100), legend=false)
    end
    display(fig7)


    """
    fig1 = plot(y[2:end], Ω_z[2:end,1], shape=:square, label="omega_z", xlabel="y", ylabel="Ω_z", xscale=:log10, legend=false)
    for j = 2:100:nx_DoI
        plot!(fig1, y[2:end], Ω_z[2:end,j], shape=:square, label="omega_z", xlabel="y", ylabel="Ω_z", xscale=:log10, legend=false)
    end
    display(fig1)

    fig2 = plot(x[ib:ie], Uₑ, shape=:square, label="Uₑ(x)", xlabel="x", ylabel="Uₑ", legend=false)
    display(fig2)

    fig3 = plot(x[ib:ie], δ₁, shape=:square, label="Uₑ(x)", xlabel="x", ylabel="δ₁", legend=false)
    display(fig3)

    fig4 = plot(x[ib:ie], δ₂, shape=:square, label="Uₑ(x)", xlabel="x", ylabel="δ₂", legend=false)
    display(fig4)

    dUedx = compute_x_derivative(dx, Uₑ) # only in DoI
    dδ₁dx = compute_x_derivative(dx, δ₁) # only in DoI
    dδ₂dx = compute_x_derivative(dx, δ₂) # only in DoI
    println(" Mean of dUₑ/dx = ", mean(dUedx))
    println(" Mean of dδ₁/dx = ", mean(dδ₁dx))
    println(" Mean of dδ₂/dx = ", mean(dδ₂dx))

    fig5 = plot(x[ib:ie], dUedx, shape=:square, xlabel="x", ylabel="dUedx", label="dU/dx")
    plot!(fig5, x[ib:ie], dδ₁dx, shape=:circ, xlabel="x", ylabel="dδ₁dx", label="dδ₁/dx")
    plot!(fig5, x[ib:ie], dδ₂dx, shape=:diamond, xlabel="x", ylabel="dδ₂dx", label="dδ₂/dx")
    display(fig5)
   
    dUdy = compute_y_derivative(y, U[:,ib:ie])
    dVdy = compute_y_derivative(y, V[:,ib:ie])
    fig6 = plot(y[2:end], dUdy[2:end,1], shape=:square, label="dU/dy", xlabel="y", ylabel="dUdy",xscale=:log10, legend=false)
    for j = 2:100:nx_DoI
        plot!(fig6, y[2:end], dUdy[2:end,j], shape=:square, label="dU/dy", xlabel="y", ylabel="dUdy", xscale=:log10, legend=false)
    end
    display(fig6)
    fig7 = plot(y[2:end], dVdy[2:end,1], shape=:circ, label="dV/dy", xlabel="y", ylabel="dVdy", xscale=:log10, legend=false)
    for j = 2:100:nx_DoI
        plot!(fig7, y[2:end], dVdy[2:end,j], shape=:circ, label="dV/dy", xlabel="y", ylabel="dVdy", xscale=:log10, legend=false)
    end
    display(fig7)
    """
end

# run the main function if this 
# if abspath(PROGRAM_FILE) == @__FILE__
    NPTS = 1000 # number of wall normal log equally spaced points
    β=(0,1,39)
    for i in 1:3
        println("Computing average statistics for β = ", β[i])
        AverageStatisticsInEtaAcrossX(NPTS, β[i])
    end    
# end